// This file has been automatically generated by Flutter Architect.
//
// Flutter Architect is a tool that generates boilerplate code for your Flutter projects.
// Flutter Architect was created at SayNode Operations AG by Yann Marti, Francesco Romeo and Pedro GonÃ§alves.
//
// https://saynode.ch
import 'dart:convert';
import 'dart:io';

import 'package:firebase_app_check/firebase_app_check.dart';
import 'package:flutter/foundation.dart';
import 'package:get/get.dart';
import 'package:http/http.dart' as http;

import '../service/logger_service.dart';
import '../util/constants.dart';

class _APIException implements Exception {
  _APIException(this.url, this.statusCode);
  final String url;
  final int statusCode;

  @override
  String toString() =>
      'A request to the backend API failed with status code [$statusCode]: $url';
}

class ParsingException extends _APIException {
  ParsingException(super.url, super.statusCode, this.message);
  final String message;

  @override
  String toString() =>
      'Failed to parse response from $url [$statusCode]: $message';
}

class ApiResponse {
  ApiResponse({
    required this.success,
    required this.statusCode,
    this.result,
    this.results,
    this.message,
  });
  ApiResponse.fromJson(Map<String, dynamic> json, this.statusCode)
      : success = json['success'] as bool,
        result = json['result'] as Map<String, dynamic>?,
        results = json['results'] as List<dynamic>?,
        message = json['message'] as String?;

  final Map<String, dynamic>? result;
  final List<dynamic>? results;
  final int statusCode;
  final String? message;
  final bool success;

  @override
  String toString() => result.toString();
}

class APIService extends GetxService {
  String authenticationToken = '';
  LoggerService loggerService = Get.find<LoggerService>();

  Future<Map<String, String>> _generateHeaders({
    bool omitBearerToken = false,
    String? contentType,
  }) async {
    String? token;

    if (kReleaseMode) {
      try {
        final String? result = await FirebaseAppCheck.instance.getToken();
        token = result;

        if (token == null || token.isEmpty) {
          loggerService.log('Firebase App Check token is null or empty');
          throw Exception('App Check token is missing');
        }

        loggerService.log('Firebase App Check token: $token');
      } catch (e) {
        loggerService.log('Failed to retrieve App Check token: $e');
        throw Exception('App Check validation failed');
      }
    } else {
      loggerService.log('App Check skipped in non-release mode');
    }

    return <String, String>{
      'key': SkillBuddyConstants.apiKey,
      if (contentType != null) 'Content-Type': contentType,
      if (!omitBearerToken)
        HttpHeaders.authorizationHeader: 'Bearer $authenticationToken',
      if (token != null && token.isNotEmpty) 'X-Firebase-AppCheck': token,
    };
  }

  Future<ApiResponse> get(
    String path, {
    String contentType = 'application/json',
    Map<String, dynamic>? queryParameters,
    bool omitBearerToken = false,
    bool log = false,
  }) async {
    final Uri url =
        Uri.https(SkillBuddyConstants.apiDomain, path, queryParameters);
    if (log) loggerService.log('API - GET to $url');

    final Map<String, String> headers = await _generateHeaders(
      omitBearerToken: omitBearerToken,
      contentType: contentType,
    );
    final http.Response response = await http.get(url, headers: headers);

    if (response.statusCode >= 500) {
      throw _APIException(path, response.statusCode);
    }

    try {
      return ApiResponse.fromJson(
        json.decode(utf8.decode(response.bodyBytes)),
        response.statusCode,
      );
    } catch (e) {
      if (e.toString().contains('type')) {
        return ApiResponse(
          success: true,
          statusCode: 200,
          message: response.body,
        );
      } else {
        throw Exception('Error occurred during GET request to $path: $e');
      }
    }
  }

  Future<ApiResponse> sendWithdrawalRequest(
    String path, {
    required Map<String, dynamic> fields,
  }) async {
    final Uri url = Uri.https(SkillBuddyConstants.apiDomain, path);

    final http.MultipartRequest request = http.MultipartRequest('POST', url);

    // ignore: always_specify_types
    fields.forEach((String key, value) {
      request.fields[key] = value.toString();
    });

    request.headers.addAll(await _generateHeaders());

    final http.StreamedResponse streamedResponse = await request.send();
    final http.Response response =
        await http.Response.fromStream(streamedResponse);

    if (response.statusCode >= 500) {
      throw _APIException(path, response.statusCode);
    }

    try {
      return ApiResponse.fromJson(
        json.decode(utf8.decode(response.bodyBytes)),
        response.statusCode,
      );
    } catch (e) {
      throw ParsingException(e.toString(), response.statusCode, path);
    }
  }

  Future<ApiResponse> post(
    String path, {
    Map<String, dynamic>? body,
    String contentType = 'application/json',
    Encoding? encoding,
    Map<String, dynamic>? queryParameters,
    bool omitBearerToken = false,
    bool log = false,
    List<http.MultipartFile>? files,
  }) async {
    final Uri url =
        Uri.https(SkillBuddyConstants.apiDomain, path, queryParameters);
    if (log) loggerService.log('API - POST to $url');

    http.Response response;

    if (files != null && files.isNotEmpty) {
      final http.MultipartRequest request = http.MultipartRequest('POST', url);
      final Map<String, String> headers =
          await _generateHeaders(omitBearerToken: omitBearerToken);
      request.headers.addAll(headers);

      body?.forEach(
        (String key, dynamic value) => request.fields[key] = value.toString(),
      );
      request.files.addAll(files);

      final http.StreamedResponse streamedResponse = await request.send();
      response = await http.Response.fromStream(streamedResponse);
    } else {
      final Map<String, String> headers = await _generateHeaders(
        omitBearerToken: omitBearerToken,
        contentType: contentType,
      );
      response = await http.post(
        url,
        headers: headers,
        body: body != null ? json.encode(body) : null,
        encoding: encoding,
      );
    }

    if (response.statusCode >= 500) {
      throw _APIException(path, response.statusCode);
    }

    try {
      return ApiResponse.fromJson(
        json.decode(utf8.decode(response.bodyBytes)),
        response.statusCode,
      );
    } catch (e) {
      throw ParsingException(e.toString(), response.statusCode, path);
    }
  }

  Future<ApiResponse> put(
    String path, {
    Map<String, dynamic>? body,
    String contentType = 'application/json',
    Encoding? encoding,
    Map<String, dynamic>? queryParameters,
    bool omitBearerToken = false,
    bool log = false,
    List<http.MultipartFile>? files,
  }) async {
    final Uri url =
        Uri.https(SkillBuddyConstants.apiDomain, path, queryParameters);
    if (log) loggerService.log('API - PUT to $url');

    if (files != null && files.isNotEmpty) {
      final http.MultipartRequest request = http.MultipartRequest('PUT', url);
      final Map<String, String> headers =
          await _generateHeaders(omitBearerToken: omitBearerToken);
      request.headers.addAll(headers);

      body?.forEach(
        (String key, dynamic value) => request.fields[key] = value.toString(),
      );
      request.files.addAll(files);

      final http.StreamedResponse streamedResponse = await request.send();
      final String responseBody = await streamedResponse.stream.bytesToString();

      if (streamedResponse.statusCode >= 500) {
        throw _APIException(path, streamedResponse.statusCode);
      }
      return ApiResponse.fromJson(
        json.decode(responseBody),
        streamedResponse.statusCode,
      );
    } else {
      final Map<String, String> headers = await _generateHeaders(
        omitBearerToken: omitBearerToken,
        contentType: contentType,
      );
      final http.Response response = await http.put(
        url,
        headers: headers,
        body: body != null ? json.encode(body) : null,
        encoding: encoding,
      );

      if (response.statusCode >= 500) {
        throw _APIException(path, response.statusCode);
      }
      return ApiResponse.fromJson(
        json.decode(utf8.decode(response.bodyBytes)),
        response.statusCode,
      );
    }
  }

  Future<ApiResponse> patch(
    String path, {
    Map<String, dynamic>? body,
    String contentType = 'application/json',
    Encoding? encoding,
    Map<String, dynamic>? queryParameters,
    bool omitBearerToken = false,
    bool log = false,
    List<http.MultipartFile>? files,
  }) async {
    final Uri url =
        Uri.https(SkillBuddyConstants.apiDomain, path, queryParameters);
    if (log) loggerService.log('API - PATCH to $url');

    if (files != null && files.isNotEmpty) {
      final http.MultipartRequest request = http.MultipartRequest('PATCH', url);
      final Map<String, String> headers =
          await _generateHeaders(omitBearerToken: omitBearerToken);
      request.headers.addAll(headers);

      body?.forEach(
        (String key, dynamic value) => request.fields[key] = value.toString(),
      );
      request.files.addAll(files);

      final http.StreamedResponse streamedResponse = await request.send();
      final String responseBody = await streamedResponse.stream.bytesToString();

      if (streamedResponse.statusCode >= 500) {
        throw _APIException(path, streamedResponse.statusCode);
      }
      return ApiResponse.fromJson(
        json.decode(responseBody),
        streamedResponse.statusCode,
      );
    } else {
      final Map<String, String> headers = await _generateHeaders(
        omitBearerToken: omitBearerToken,
        contentType: contentType,
      );
      final http.Response response = await http.patch(
        url,
        headers: headers,
        body: body != null ? json.encode(body) : null,
        encoding: encoding,
      );

      if (response.statusCode >= 500) {
        throw _APIException(path, response.statusCode);
      }
      return ApiResponse.fromJson(
        json.decode(utf8.decode(response.bodyBytes)),
        response.statusCode,
      );
    }
  }

  Future<ApiResponse> delete(
    String path, {
    Map<String, dynamic>? body,
    String contentType = 'application/json',
    Encoding? encoding,
    Map<String, dynamic>? queryParameters,
    bool omitBearerToken = false,
    bool log = false,
  }) async {
    final Uri url =
        Uri.https(SkillBuddyConstants.apiDomain, path, queryParameters);
    if (log) loggerService.log('API - DELETE to $url');

    final Map<String, String> headers = await _generateHeaders(
      omitBearerToken: omitBearerToken,
      contentType: contentType,
    );
    final http.Response response = await http.delete(
      url,
      headers: headers,
      body: body != null ? json.encode(body) : null,
      encoding: encoding,
    );

    if (response.statusCode >= 500) {
      throw _APIException(path, response.statusCode);
    }

    return ApiResponse.fromJson(
      json.decode(utf8.decode(response.bodyBytes)),
      response.statusCode,
    );
  }
}
