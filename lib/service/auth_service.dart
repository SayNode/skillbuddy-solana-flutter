// This file has been automatically generated by Flutter Architect.
//
// Flutter Architect is a tool that generates boilerplate code for your Flutter projects.
// Flutter Architect was created at SayNode Operations AG by Yann Marti, Francesco Romeo and Pedro Gon√ßalves.
//
// https://saynode.ch

import 'package:flutter/foundation.dart';
import 'package:flutter/services.dart';
import 'package:get/get.dart';
import 'package:google_sign_in/google_sign_in.dart';
import 'package:sign_in_with_apple/sign_in_with_apple.dart';

import '../base/auth_base_service.dart';
import '../model/events/account_creation_event.dart';
import '../model/events/account_login_event.dart';
import '../model/user_model.dart';
import 'api_service.dart';
import 'event_service.dart';
import 'user_state_service.dart';

class AuthService extends AuthBaseService {
  void loginEvent(
    bool isSignup,
    String userAuthenticationMethod,
  ) {
    final User user = Get.find<UserStateService>().user.value;
    if (isSignup) {
      // Track sign up event
      Get.find<EventService>().trackEvent(
        AccountCreationEvent(
          user.id.toString(),
          user.name,
          user.email,
          userAuthenticationMethod,
        ),
      );
    }
    // Track login event
    Get.find<EventService>().trackEvent(
      AccountLoginEvent(
        user.id.toString(),
        user.name,
        user.email,
        userAuthenticationMethod,
      ),
    );
  }

  @override
  Future<ApiResponse> silentLogin() async {
    final ApiResponse ret = await super.silentLogin();
    if (ret.statusCode == 200) {
      loginEvent(false, 'silent login with token');
    }
    return ret;
  }

  @override
  Future<ApiResponse> registration(
    String email,
    String password,
    String username, {
    required bool biometrics,
  }) async {
    final ApiResponse ret = await super.registration(
      email,
      password,
      username,
      biometrics: biometrics,
    );
    if (ret.statusCode == 200 || ret.statusCode == 201) {
      loginEvent(true, 'email and password');
    }
    return ret;
  }

  @override
  Future<ApiResponse> login(
    String email,
    String password,
  ) async {
    final ApiResponse ret = await super.login(
      email,
      password,
    );
    if (ret.statusCode == 200) {
      loginEvent(false, 'email and password');
    }
    return ret;
  }

  // Add your custom code here
  // Login with Apple.
  Future<ApiResponse> appleSignIn({
    String? authorizationCode,
    String? identityToken,
    String? givenName,
  }) async {
    try {
      if (authorizationCode != null &&
          identityToken != null &&
          authorizationCode.isNotEmpty &&
          identityToken.isNotEmpty) {
        debugPrint('AuthService - Apple Sign In with code and token');
      } else {
        final AuthorizationCredentialAppleID credential =
            await SignInWithApple.getAppleIDCredential(
          scopes: <AppleIDAuthorizationScopes>[
            AppleIDAuthorizationScopes.email,
            AppleIDAuthorizationScopes.fullName,
          ],
          webAuthenticationOptions: WebAuthenticationOptions(
            clientId: 'io.skillbuddy.academy',
            redirectUri:
                // For web your redirect URI needs to be the host of the "current page",
                // while for Android you will be using the API server that redirects back into your app via a deep link
                kIsWeb
                    ? Uri.parse('io.skillbuddy.academy')
                    : Uri.parse('io.skillbuddy.academy'),
          ),
        );

        authorizationCode = credential.authorizationCode;
        identityToken = credential.identityToken;
        givenName = credential.givenName;
      }

      // This is the endpoint that will convert an authorization code obtained
      // via Sign in with Apple into a session in your system
      final ApiResponse response = await apiService.post(
        'auth/apple/',
        omitBearerToken: true,
        body: <String, dynamic>{
          'access_token': authorizationCode,
          'id_token': identityToken,
        },
      );

      if (response.statusCode == 200) {
        try {
          /// Save the token
          apiService.authenticationToken = response.result?['access_token'];
          await storageService.secure.writeString(
            'token',
            response.result?['access_token'],
          );
          if (givenName != null) {
            await Get.find<UserStateService>().update(
              userName: givenName,
            );
          }
          await Get.find<UserStateService>().get();

          loginEvent(
            response.result?['is_signup'] ?? false,
            'apple',
          );

          return response;
        } catch (error) {
          await disconnectProviders();
          throw Exception('AuthService - error while parsing the user: $error');
        }
      } else {
        await disconnectProviders();
        return response;
      }
    } //handles the error if user cancels apple signin and stops app crashing
    on PlatformException catch (e) {
      if (e.code == 'cancelled') {
        // User canceled the sign in
        return ApiResponse(
          result: <String, dynamic>{},
          message: 'Sign in cancelled',
          statusCode: 0,
          success: false,
        );
      } else {
        // Other authorization error occurred
        throw Exception('Authorization error: $e');
      }
    } on SignInWithAppleAuthorizationException catch (e) {
      // Other error occurred
      return ApiResponse(
        result: <String, dynamic>{},
        message: e.message,
        statusCode: 0,
        success: false,
      );
    } catch (e) {
      // Other error occurred
      throw Exception('Authorization error: $e');
    }
  }

  late GoogleSignIn _googleSignIn;

  void init() {
    _googleSignIn = GoogleSignIn(
      scopes: <String>[
        'email',
      ],
    );
  }

  // Login with Google.
  Future<ApiResponse> googleSignIn() async {
    try {
      // Clear cache
      await _googleSignIn.currentUser?.clearAuthCache();

      // Try to login silently
      final GoogleSignInAccount? result =
          await _googleSignIn.signInSilently() ?? await _googleSignIn.signIn();

      if (result != null) {
        final GoogleSignInAuthentication googleKey =
            await result.authentication;
        // Login in backend
        final ApiResponse response = await apiService.post(
          'auth/google/',
          body: <String, dynamic>{
            'access_token': googleKey.accessToken,
            'id_token': googleKey.idToken,
          },
          omitBearerToken: true,
        );

        if (response.statusCode == 200) {
          try {
            /// Save the token
            apiService.authenticationToken = response.result?['access_token'];
            await storageService.secure.writeString(
              'token',
              response.result?['access_token'],
            );

            await Get.find<UserStateService>().get();

            loginEvent(
              response.result?['is_signup'] ?? false,
              'google',
            );

            return response;
          } catch (error) {
            await disconnectProviders();
            throw Exception(
              'AuthService - error while parsing the user: $error',
            );
          }
        } else if (response.statusCode == 400) {
          await disconnectProviders();
          return response;
        } else {
          await disconnectProviders();
          throw Exception('AuthService - ${response.message}');
        }
      }
      return ApiResponse(
        result: <String, dynamic>{},
        message:
            "Google auth isn't working at the moment. Please try again later.",
        statusCode: 0,
        success: false,
      );
    } catch (e) {
      // Other error occurred
      throw Exception('Catched an error while logging in with Google: $e');
    }
  }

  @override
  Future<void> disconnectProviders() async {
    // Disconnect providers
    // Disconnect from Apple.

    // Disconnect from Google.
    if (await _googleSignIn.isSignedIn()) {
      try {
        await _googleSignIn.disconnect();
      } catch (e) {
        throw Exception(
          'AuthService - error while disconnecting from google: $e',
        );
      }
    }
    await super.disconnectProviders();
  }
}
